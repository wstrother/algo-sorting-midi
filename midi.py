"""
This file will provide a method that takes 
    - a list of numbers (correpsonding to the index of array accesses generated by a sorting algorithm)
    - general parameters for the style of output (rhythmic guidelines, note mapping)

and generate a MIDI file as output.
"""

from midiutil import MIDIFile


class NoteGenerator:
    def __init__(self, default_t=1, tempo=120) -> None:
        self.current_t = 0
        self.default_t = default_t
        
        self.midi = MIDIFile(1)
        self.midi.addTempo(0, 0, tempo)
        
        self.pattern = [
            [1, 100]
        ]
        self.notes = []
        self.scaling_factor = 1
        self.modular_div = True
        self.skip_rests = False

    def get_pattern_step(self, step_number) -> list:
        return self.pattern[step_number % len(self.pattern)]

    def get_pitch(self, value) -> int:
        if not self.notes:
            return value
        
        value = int(value * self.scaling_factor)
        
        if self.modular_div:
            value = value % len(self.notes)
        
        try:
            return self.notes[value]
        except IndexError:
            return self.notes[-1]
    
    def get_duration(self, step_number) -> float:
        step = self.get_pattern_step(step_number)
        
        return step[0]
    
    def get_volume(self, step_number) -> int:
        step = self.get_pattern_step(step_number)
        
        return step[1]

    def get_delta_t(self, step_number) -> float:
        step = self.get_pattern_step(step_number)
        
        if len(step) == 2:
            return step[0]
        else:
            return step[2]

    def process_step(self, value, step_number):
        # set defaults
        pitch, duration, volume = 0, 0, 0
        
        # if there is no index value in the step, consider it a rest
        add_note = True
        rest = value is None
        if rest and self.skip_rests:
            add_note = False
        
        if not rest:
            # apply transformations
            pitch = self.get_pitch(value)
            duration = self.get_duration(step_number)
            volume = self.get_volume(step_number)
            
            # write midi note
            self.midi.addNote(0, 0, pitch, self.current_t, duration, volume)
        
        # increment current time
        if add_note:
            self.current_t += self.get_delta_t(step_number)
    
    def write_file(self, file_name):
        with open(file_name, "wb") as output_file:
            self.midi.writeFile(output_file)
    
    def create_midi(self, steps, file_name):
        values = [step[1] for step in steps]
        
        for (step_number, value) in enumerate(values):
            self.process_step(value, step_number)
        
        self.write_file(file_name)

